var exec = require('child-process-promise').exec
var fs = require('fs-extra')
var path = require('path')
var mkdirp = require('mkdirp')
var tmp = require('tmp-promise')

var ffprobe = require('ffprobe')
var which = require('which')
var ffopt = {path: which.sync('ffprobe')}

var chalk = require('chalk')

var cleanups = [];

function divisable(val) {
	return Math.round(val / 2) * 2
}
function autoscale(w, ow, oh){
	// oh/ow: aspect ratio
	var t = Math.round(w*oh/ow)
	return t%2==0 ? t : t+1
}

//start and duration given in seconds!
async function clip(input, output, start, duration, options, originalDims, rotation) {
	//if one of options.w or options.h is omitted, autoscale that dimension
	//if both are omitted, set w to 300 and h to auto
	//if both are given, use those dimensions

	var ah = autoscale(300, originalDims.w, originalDims.h)
	var aw = autoscale(300, originalDims.h, originalDims.w)

	var w, h

	if (typeof (options) === 'undefined') {
		w = h = false
	} else {
		w = typeof (options.width) !== 'undefined'
		h = typeof (options.height) !== 'undefined'
	}

	var d = {}

	if (w && h) {
		d.w = options.width
		d.h = options.height
	} else if (w) {
		d.w = options.width
		d.h = autoscale(options.width, originalDims.w, originalDims.h)
	} else if (h) {
		d.h = autoscale(options.height, originalDims.h, originalDims.w)
		d.h = options.height
	} else {
		d.w = 300
		d.h = ah
	}
	
	//swap height and width if video is rotated 90deg
	if(rotation == 90){
		[d.w, d.h] = [d.h, d.w]
	}

	var cmd = `ffmpeg -y -i '${input}' -ss ${timecode(start)} -t ${timecode(duration)} -r 8 -vf "scale=${d.w}:${d.h}" -an -c:v libx264 '${output}'`

	try { return exec(cmd) } catch (err) {
		console.log('Error occurred, run this command to debug: ' + cmd)
	}
}

module.exports.clip = clip
module.exports.video = video

async function video(input, output, options) {
	//make 5 seconds three times, to temporary files
	/*
	input: path,
	output: path,
	options: {
		width: number,
		height: number
	}
	*/

	if (typeof (input) !== 'string')
		throw ('Input should be a string')
	try { await fs.access(input) }
	catch (er) { throw ('Input file doesn\'t exist') }


	if (typeof (output) !== 'string') {
		//if out not given, save under ${inputName}-preview.mp4
		var name = path.basename(input, path.extname(input))
		//mp4 only:
		output = path.join(path.dirname(input), name + '-preview.mp4')
		if(typeof(options.silent) !== 'undefined' && !options.silent)
		console.log(chalk.gray('info: Outputting to ') + chalk.dim.underline(output))
	}

	//make sure the directory to output exists
	var dir = path.dirname(output)
	try { await fs.access(dir) }
	catch (er) { mkdirp.sync(dir) }

	var probe = await ffprobe(input, ffopt)
	var info = probe.streams;

    var rotation = parseInt(info[0].tags.rotate)
    var originalDims = {w: parseInt(info[0].width), h: parseInt(info[0].height)}
	var seconds = parseInt(info[1].duration)

	//take one clip from the start, one from the middle and one in the end.
	var p = Math.round(seconds / 3)
	var timecodes = [
		getRandomInt(0, p),
		getRandomInt(p, p * 2),
		getRandomInt(p * 2, seconds)
	]

	//holds the temporary paths generated by tmp
	var paths = [];

	//make clips up to 3 seconds
	var clipLength = Math.min(3, seconds)
	//make up to 3 clips (and at least 1)
	var max = Math.min(Math.floor(seconds / clipLength) + 1, 3)
	var promises = []
	for (var i = 0; i < max; i++) {
		var o = await tmp.file({
			prefix: 'video-thumbnail-part',
			postfix: '.mp4',
			discardDescriptor: true,
			keep: true
		})

		paths.push(o.path)
		cleanups.push(o.cleanup)

		//parallelises the rendering by allowing all clips to execute at the same time, then waiting for all of them to finish.
		promises.push(clip(input, o.path, timecodes[i], clipLength, options, originalDims, rotation))
	}

	await Promise.all(promises)
	//concat the files into a tmp file
	var o = await tmp.file({
		prefix: 'video-thumbnail-list',
		postfix: '.txt',
		keep: true
	})
	var data = paths.map((e) => {
		return `file '${e}'`
	}).join('\n');
	fs.writeFileSync(o.fd, data);

	var cmd = `ffmpeg -y -safe 0 -f concat -i '${o.path}' -c:v libx264 -an '${output}'`
	var res = await exec(cmd)
	cleanups.forEach((e) => {
		e();
	})
	o.cleanup();

	return output
}

function getRandomInt(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}

function timecode(sec_num) {
	var hours = Math.floor(sec_num / 3600);
	var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
	var seconds = sec_num - (hours * 3600) - (minutes * 60);

	if (hours < 10) {
		hours = "0" + hours;
	}
	if (minutes < 10) {
		minutes = "0" + minutes;
	}
	if (seconds < 10) {
		seconds = "0" + seconds;
	}
	return hours + ':' + minutes + ':' + seconds;
	//from https://stackoverflow.com/questions/6312993/javascript-seconds-to-time-string-with-format-hhmmss
}